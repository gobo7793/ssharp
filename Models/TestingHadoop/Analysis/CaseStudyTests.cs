#region License
// The MIT License (MIT)
// 
// Copyright (c) 2014-2018, Institute for Software & Systems Engineering
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
#endregion

using System;
using System.Collections;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Threading;
using NUnit.Framework;
using SafetySharp.CaseStudies.TestingHadoop.Modeling;
using SafetySharp.CaseStudies.TestingHadoop.Modeling.Driver.Connector;

namespace SafetySharp.CaseStudies.TestingHadoop.Analysis
{
    [TestFixture]
    public class CaseStudyTests
    {

        #region Settings

        private static log4net.ILog Logger { get; } =
            log4net.LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

        private string MutationConfig = "mut";

        #endregion

        #region Preparing

        /// <summary>
        /// Generate the case study seeds
        /// </summary>
        [Test]
        public void GenerateCaseStudyBenchSeeds()
        {
            var ticks = Environment.TickCount;
            var ran = new Random(ticks);
            var s1 = ran.Next(int.MinValue, int.MaxValue);
            var s2 = ran.Next(int.MinValue, int.MaxValue);
            var s3 = ran.Next(int.MinValue, int.MaxValue);
            Console.WriteLine($"Ticks: {ticks:X} | s1: {s1:X} | s2: {s2:X} | s3: {s3:X}");
            // Specific output for generating test case seeds:
            // Ticks: 40595187 | s1: 105838460 | s2: -2044864785 | s3: 514633513
        }

        #endregion

        #region Test cases

        /// <summary>
        /// Returns the test cases for nunit
        /// </summary>
        /// <returns>A test case</returns>
        public IEnumerable GetTestCases()
        {
            foreach(var seed in GetSeeds())
            foreach(var prob in GetFaultProbabilities())
            foreach(var hosts in GetHostCounts())
            foreach(var clients in GetClientCounts())
            foreach(var steps in GetStepCounts())
            foreach(var isMut in GetIsMutated())
                yield return new TestCaseData(seed, prob, hosts, clients, steps, isMut);
        }

        /// <summary>
        /// The seeds to use
        /// </summary>
        private IEnumerable GetSeeds()
        {
            yield return 123;
            yield return 456;
            yield return 789;
        }

        /// <summary>
        /// The general fault injection/repair probabilities to use in test cases
        /// </summary>
        private IEnumerable GetFaultProbabilities()
        {
            yield return 0.0;
            yield return 0.3;
        }

        /// <summary>
        /// The hosts counts to use in test cases
        /// </summary>
        private IEnumerable GetHostCounts()
        {
            yield return 1;
            yield return 2;
        }

        /// <summary>
        /// The client counts to use in test cases
        /// </summary>
        private IEnumerable GetClientCounts()
        {
            yield return 1;
            yield return 2;
        }

        /// <summary>
        /// The step counts to use in test cases
        /// </summary>
        private IEnumerable GetStepCounts()
        {
            yield return 5;
            yield return 15;
        }

        /// <summary>
        /// Indicates if the cluster is mutated for the test cases
        /// </summary>
        private IEnumerable GetIsMutated()
        {
            yield return true;
            yield return false;
        }

        #endregion

        #region Execution

        /// <summary>
        /// Executing the case study. Test cases will be generated by <see cref="GetTestCases"/>
        /// </summary>
        /// <param name="benchmarkSeed">The benchmark seed</param>
        /// <param name="faultProbability">The base probability for faults</param>
        /// <param name="hostsCount">The hosts count</param>
        /// <param name="clientCount">The client count</param>
        /// <param name="stepCount">The step count</param>
        /// <param name="isMutated">Using the mutated cluster scenario</param>
        [Test]
        [TestCaseSource(nameof(GetTestCases))]
        public void ExecuteCaseStudy(int benchmarkSeed, double faultProbability, int hostsCount,
                                     int clientCount, int stepCount, bool isMutated)
        {
            Logger.Info("Starting Case Study test");
            Logger.Info("Parameter:");
            Logger.Info($"  benchmarkSeed=    {benchmarkSeed}");
            Logger.Info($"  faultProbability= {faultProbability}");
            Logger.Info($"  hostsCount=       {hostsCount}");
            Logger.Info($"  clientCount=      {clientCount}");
            Logger.Info($"  stepCount=        {stepCount}");
            Logger.Info($"  isMutated=        {isMutated}");

            StartCluster(hostsCount, isMutated);
            Thread.Sleep(5000); // wait for startup

            Logger.Info("Setting up test case");
            var simTest = new SimulationTests
            {
                MinStepTime = new TimeSpan(0, 0, 0, 25),
                RecreatePreInputs = true,
                PrecreatedInputs = true,
                NodeBaseCount = 4,

                BenchmarkSeed = benchmarkSeed,
                FaultActivationProbability = faultProbability,
                FaultRepairProbability = faultProbability,
                HostsCount = hostsCount,
                ClientCount = clientCount,

                StepCount = stepCount,
            };

            // execute
            simTest.SimulateHadoopFaults();

            StopCluster();

            // move logs
            MoveCaseStudyLogs(benchmarkSeed, faultProbability, hostsCount,
                clientCount, stepCount, isMutated);
        }

        #endregion

        #region Utilities

        /// <summary>
        /// Starts the Cluster for the case study
        /// </summary>
        /// <param name="hostsCount">The hosts count</param>
        /// <param name="isMutated">True if the mutated scenario should be started</param>
        private void StartCluster(int hostsCount, bool isMutated)
        {
            Logger.Info($"Start cluster on {hostsCount} hosts (mutated: {isMutated})");
            ModelSettings.HostMode = ModelSettings.EHostMode.Multihost;
            ModelSettings.HostsCount = hostsCount;

            var config = isMutated ? MutationConfig : String.Empty;

            var connector = CmdConnector.Instance;
            var isStarted = connector.StartCluster(config);
            Logger.Info($"Is cluster started: {isStarted}");
            Assert.IsTrue(isStarted, $"failed to start cluster on {hostsCount} hosts (mutated: {isMutated})");
        }

        /// <summary>
        /// Stops the cluster
        /// </summary>
        private void StopCluster()
        {
            Logger.Info("Stop cluster");
            var isStopped = CmdConnector.Instance.StopCluster();
            Logger.Info($"Is cluster stopped: {isStopped}");
            Assert.IsTrue(isStopped, "failed to stop cluster)");
        }

        /// <summary>
        /// Moving the case study log files so each case study has its own logs.
        /// Logs will be moved from /logs to /testingHadoopCaseStudyLogs with
        /// following filename scheme:
        /// "<see cref="benchmarkSeed"/>-<see cref="faultProbability"/>-
        /// <see cref="hostsCount"/>-<see cref="clientCount"/>-
        /// <see cref="stepCount"/>-<see cref="isMutated"/>-today"
        /// where today is in format "yyMMdd".
        /// </summary>
        /// <param name="benchmarkSeed">The benchmark seed</param>
        /// <param name="faultProbability">The base probability for faults</param>
        /// <param name="hostsCount">The hosts count</param>
        /// <param name="clientCount">The client count</param>
        /// <param name="stepCount">The step count</param>
        /// <param name="isMutated">Using the mutated cluster scenario</param>
        private void MoveCaseStudyLogs(int benchmarkSeed, double faultProbability, int hostsCount,
                                       int clientCount, int stepCount, bool isMutated)
        {
            var origLogDir = $@"{Environment.CurrentDirectory}\logs";
            var todayStrLong = DateTime.Today.ToString("yyyy-MM-dd");
            var origLogFile = $@"{origLogDir}\{todayStrLong}.log";
            var origSshLog = $@"{origLogDir}\{todayStrLong}-sshout.log";

            var caseStudyLogDir = $@"{Environment.CurrentDirectory}\testingHadoopCaseStudyLogs";
            var todayStrShort = DateTime.Today.ToString("yyMMdd");
            var mutatedInt = isMutated ? 1 : 0;
            var faultProbStr = faultProbability.ToString(CultureInfo.InvariantCulture);
            var filename = $"{benchmarkSeed:X8}-{faultProbStr}-{hostsCount:D1}-" +
                           $"{clientCount:D1}-{stepCount:D2}-{mutatedInt:D1}-{todayStrShort}";
            var newLogFile = $@"{caseStudyLogDir}\{filename}.log";
            var newSshLog = $@"{caseStudyLogDir}\{filename}-ssh.log";

            Directory.CreateDirectory(caseStudyLogDir);
            File.Move(origLogFile, newLogFile);
            File.Move(origSshLog, newSshLog);
        }

        #endregion

    }
}